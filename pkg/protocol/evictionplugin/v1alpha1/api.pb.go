/*
Copyright 2022 The Katalyst Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1alpha1/api.proto

package v1alpha1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	v1 "k8s.io/api/core/v1"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ThresholdMetType int32

const (
	ThresholdMetType_NOT_MET  ThresholdMetType = 0
	ThresholdMetType_SOFT_MET ThresholdMetType = 1
	ThresholdMetType_HARD_MET ThresholdMetType = 2
)

var ThresholdMetType_name = map[int32]string{
	0: "NOT_MET",
	1: "SOFT_MET",
	2: "HARD_MET",
}

var ThresholdMetType_value = map[string]int32{
	"NOT_MET":  0,
	"SOFT_MET": 1,
	"HARD_MET": 2,
}

func (x ThresholdMetType) String() string {
	return proto.EnumName(ThresholdMetType_name, int32(x))
}

func (ThresholdMetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{0}
}

type ThresholdOperator int32

const (
	ThresholdOperator_LESS_THAN    ThresholdOperator = 0
	ThresholdOperator_GREATER_THAN ThresholdOperator = 1
)

var ThresholdOperator_name = map[int32]string{
	0: "LESS_THAN",
	1: "GREATER_THAN",
}

var ThresholdOperator_value = map[string]int32{
	"LESS_THAN":    0,
	"GREATER_THAN": 1,
}

func (x ThresholdOperator) String() string {
	return proto.EnumName(ThresholdOperator_name, int32(x))
}

func (ThresholdOperator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{1}
}

type ConditionType int32

const (
	ConditionType_NODE_CONDITION ConditionType = 0
	ConditionType_CNR_CONDITION  ConditionType = 1
)

var ConditionType_name = map[int32]string{
	0: "NODE_CONDITION",
	1: "CNR_CONDITION",
}

var ConditionType_value = map[string]int32{
	"NODE_CONDITION": 0,
	"CNR_CONDITION":  1,
}

func (x ConditionType) String() string {
	return proto.EnumName(ConditionType_name, int32(x))
}

func (ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{2}
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Condition struct {
	ConditionType        ConditionType `protobuf:"varint,1,opt,name=condition_type,json=conditionType,proto3,enum=evictionplugin.v1alpha1.ConditionType" json:"condition_type,omitempty"`
	Effects              []string      `protobuf:"bytes,2,rep,name=effects,proto3" json:"effects,omitempty"`
	ConditionName        string        `protobuf:"bytes,3,opt,name=condition_name,json=conditionName,proto3" json:"condition_name,omitempty"`
	MetCondition         bool          `protobuf:"varint,4,opt,name=met_condition,json=metCondition,proto3" json:"met_condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Condition) Reset()      { *m = Condition{} }
func (*Condition) ProtoMessage() {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{1}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetConditionType() ConditionType {
	if m != nil {
		return m.ConditionType
	}
	return ConditionType_NODE_CONDITION
}

func (m *Condition) GetEffects() []string {
	if m != nil {
		return m.Effects
	}
	return nil
}

func (m *Condition) GetConditionName() string {
	if m != nil {
		return m.ConditionName
	}
	return ""
}

func (m *Condition) GetMetCondition() bool {
	if m != nil {
		return m.MetCondition
	}
	return false
}

type ThresholdMetResponse struct {
	ThresholdValue       float64           `protobuf:"fixed64,1,opt,name=threshold_value,json=thresholdValue,proto3" json:"threshold_value,omitempty"`
	ObservedValue        float64           `protobuf:"fixed64,2,opt,name=observed_value,json=observedValue,proto3" json:"observed_value,omitempty"`
	ThresholdOperator    ThresholdOperator `protobuf:"varint,3,opt,name=threshold_operator,json=thresholdOperator,proto3,enum=evictionplugin.v1alpha1.ThresholdOperator" json:"threshold_operator,omitempty"`
	MetType              ThresholdMetType  `protobuf:"varint,4,opt,name=met_type,json=metType,proto3,enum=evictionplugin.v1alpha1.ThresholdMetType" json:"met_type,omitempty"`
	EvictionScope        string            `protobuf:"bytes,5,opt,name=eviction_scope,json=evictionScope,proto3" json:"eviction_scope,omitempty"`
	GracePeriodSeconds   int64             `protobuf:"varint,6,opt,name=grace_period_seconds,json=gracePeriodSeconds,proto3" json:"grace_period_seconds,omitempty"`
	Condition            *Condition        `protobuf:"bytes,7,opt,name=condition,proto3" json:"condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ThresholdMetResponse) Reset()      { *m = ThresholdMetResponse{} }
func (*ThresholdMetResponse) ProtoMessage() {}
func (*ThresholdMetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{2}
}
func (m *ThresholdMetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdMetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdMetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdMetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdMetResponse.Merge(m, src)
}
func (m *ThresholdMetResponse) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdMetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdMetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdMetResponse proto.InternalMessageInfo

func (m *ThresholdMetResponse) GetThresholdValue() float64 {
	if m != nil {
		return m.ThresholdValue
	}
	return 0
}

func (m *ThresholdMetResponse) GetObservedValue() float64 {
	if m != nil {
		return m.ObservedValue
	}
	return 0
}

func (m *ThresholdMetResponse) GetThresholdOperator() ThresholdOperator {
	if m != nil {
		return m.ThresholdOperator
	}
	return ThresholdOperator_LESS_THAN
}

func (m *ThresholdMetResponse) GetMetType() ThresholdMetType {
	if m != nil {
		return m.MetType
	}
	return ThresholdMetType_NOT_MET
}

func (m *ThresholdMetResponse) GetEvictionScope() string {
	if m != nil {
		return m.EvictionScope
	}
	return ""
}

func (m *ThresholdMetResponse) GetGracePeriodSeconds() int64 {
	if m != nil {
		return m.GracePeriodSeconds
	}
	return 0
}

func (m *ThresholdMetResponse) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

type GetTopEvictionPodsRequest struct {
	ActivePods           []*v1.Pod `protobuf:"bytes,1,rep,name=active_pods,json=activePods,proto3" json:"active_pods,omitempty"`
	TopN                 uint64    `protobuf:"varint,2,opt,name=topN,proto3" json:"topN,omitempty"`
	EvictionScope        string    `protobuf:"bytes,3,opt,name=eviction_scope,json=evictionScope,proto3" json:"eviction_scope,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetTopEvictionPodsRequest) Reset()      { *m = GetTopEvictionPodsRequest{} }
func (*GetTopEvictionPodsRequest) ProtoMessage() {}
func (*GetTopEvictionPodsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{3}
}
func (m *GetTopEvictionPodsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopEvictionPodsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopEvictionPodsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTopEvictionPodsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopEvictionPodsRequest.Merge(m, src)
}
func (m *GetTopEvictionPodsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTopEvictionPodsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopEvictionPodsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopEvictionPodsRequest proto.InternalMessageInfo

func (m *GetTopEvictionPodsRequest) GetActivePods() []*v1.Pod {
	if m != nil {
		return m.ActivePods
	}
	return nil
}

func (m *GetTopEvictionPodsRequest) GetTopN() uint64 {
	if m != nil {
		return m.TopN
	}
	return 0
}

func (m *GetTopEvictionPodsRequest) GetEvictionScope() string {
	if m != nil {
		return m.EvictionScope
	}
	return ""
}

type GetTopEvictionPodsResponse struct {
	TargetPods           []*v1.Pod        `protobuf:"bytes,1,rep,name=target_pods,json=targetPods,proto3" json:"target_pods,omitempty"`
	DeletionOptions      *DeletionOptions `protobuf:"bytes,2,opt,name=deletion_options,json=deletionOptions,proto3" json:"deletion_options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetTopEvictionPodsResponse) Reset()      { *m = GetTopEvictionPodsResponse{} }
func (*GetTopEvictionPodsResponse) ProtoMessage() {}
func (*GetTopEvictionPodsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{4}
}
func (m *GetTopEvictionPodsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopEvictionPodsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopEvictionPodsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTopEvictionPodsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopEvictionPodsResponse.Merge(m, src)
}
func (m *GetTopEvictionPodsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTopEvictionPodsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopEvictionPodsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopEvictionPodsResponse proto.InternalMessageInfo

func (m *GetTopEvictionPodsResponse) GetTargetPods() []*v1.Pod {
	if m != nil {
		return m.TargetPods
	}
	return nil
}

func (m *GetTopEvictionPodsResponse) GetDeletionOptions() *DeletionOptions {
	if m != nil {
		return m.DeletionOptions
	}
	return nil
}

type EvictPod struct {
	Pod                  *v1.Pod          `protobuf:"bytes,1,opt,name=pod,proto3" json:"pod,omitempty"`
	Reason               string           `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	DeletionOptions      *DeletionOptions `protobuf:"bytes,3,opt,name=deletion_options,json=deletionOptions,proto3" json:"deletion_options,omitempty"`
	ForceEvict           bool             `protobuf:"varint,4,opt,name=force_evict,json=forceEvict,proto3" json:"force_evict,omitempty"`
	EvictionPluginName   string           `protobuf:"bytes,5,opt,name=eviction_plugin_name,json=evictionPluginName,proto3" json:"eviction_plugin_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EvictPod) Reset()      { *m = EvictPod{} }
func (*EvictPod) ProtoMessage() {}
func (*EvictPod) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{5}
}
func (m *EvictPod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvictPod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvictPod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvictPod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvictPod.Merge(m, src)
}
func (m *EvictPod) XXX_Size() int {
	return m.Size()
}
func (m *EvictPod) XXX_DiscardUnknown() {
	xxx_messageInfo_EvictPod.DiscardUnknown(m)
}

var xxx_messageInfo_EvictPod proto.InternalMessageInfo

func (m *EvictPod) GetPod() *v1.Pod {
	if m != nil {
		return m.Pod
	}
	return nil
}

func (m *EvictPod) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EvictPod) GetDeletionOptions() *DeletionOptions {
	if m != nil {
		return m.DeletionOptions
	}
	return nil
}

func (m *EvictPod) GetForceEvict() bool {
	if m != nil {
		return m.ForceEvict
	}
	return false
}

func (m *EvictPod) GetEvictionPluginName() string {
	if m != nil {
		return m.EvictionPluginName
	}
	return ""
}

type GetEvictPodsRequest struct {
	ActivePods           []*v1.Pod `protobuf:"bytes,1,rep,name=active_pods,json=activePods,proto3" json:"active_pods,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetEvictPodsRequest) Reset()      { *m = GetEvictPodsRequest{} }
func (*GetEvictPodsRequest) ProtoMessage() {}
func (*GetEvictPodsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{6}
}
func (m *GetEvictPodsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEvictPodsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEvictPodsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEvictPodsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEvictPodsRequest.Merge(m, src)
}
func (m *GetEvictPodsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetEvictPodsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEvictPodsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetEvictPodsRequest proto.InternalMessageInfo

func (m *GetEvictPodsRequest) GetActivePods() []*v1.Pod {
	if m != nil {
		return m.ActivePods
	}
	return nil
}

type GetEvictPodsResponse struct {
	EvictPods            []*EvictPod `protobuf:"bytes,1,rep,name=evict_pods,json=evictPods,proto3" json:"evict_pods,omitempty"`
	Condition            *Condition  `protobuf:"bytes,2,opt,name=condition,proto3" json:"condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetEvictPodsResponse) Reset()      { *m = GetEvictPodsResponse{} }
func (*GetEvictPodsResponse) ProtoMessage() {}
func (*GetEvictPodsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{7}
}
func (m *GetEvictPodsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEvictPodsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEvictPodsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEvictPodsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEvictPodsResponse.Merge(m, src)
}
func (m *GetEvictPodsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetEvictPodsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEvictPodsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetEvictPodsResponse proto.InternalMessageInfo

func (m *GetEvictPodsResponse) GetEvictPods() []*EvictPod {
	if m != nil {
		return m.EvictPods
	}
	return nil
}

func (m *GetEvictPodsResponse) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

type DeletionOptions struct {
	GracePeriodSeconds   int64    `protobuf:"varint,1,opt,name=grace_period_seconds,json=gracePeriodSeconds,proto3" json:"grace_period_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeletionOptions) Reset()      { *m = DeletionOptions{} }
func (*DeletionOptions) ProtoMessage() {}
func (*DeletionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_78941759e4c5eff9, []int{8}
}
func (m *DeletionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletionOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletionOptions.Merge(m, src)
}
func (m *DeletionOptions) XXX_Size() int {
	return m.Size()
}
func (m *DeletionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DeletionOptions proto.InternalMessageInfo

func (m *DeletionOptions) GetGracePeriodSeconds() int64 {
	if m != nil {
		return m.GracePeriodSeconds
	}
	return 0
}

func init() {
	proto.RegisterEnum("evictionplugin.v1alpha1.ThresholdMetType", ThresholdMetType_name, ThresholdMetType_value)
	proto.RegisterEnum("evictionplugin.v1alpha1.ThresholdOperator", ThresholdOperator_name, ThresholdOperator_value)
	proto.RegisterEnum("evictionplugin.v1alpha1.ConditionType", ConditionType_name, ConditionType_value)
	proto.RegisterType((*Empty)(nil), "evictionplugin.v1alpha1.Empty")
	proto.RegisterType((*Condition)(nil), "evictionplugin.v1alpha1.Condition")
	proto.RegisterType((*ThresholdMetResponse)(nil), "evictionplugin.v1alpha1.ThresholdMetResponse")
	proto.RegisterType((*GetTopEvictionPodsRequest)(nil), "evictionplugin.v1alpha1.GetTopEvictionPodsRequest")
	proto.RegisterType((*GetTopEvictionPodsResponse)(nil), "evictionplugin.v1alpha1.GetTopEvictionPodsResponse")
	proto.RegisterType((*EvictPod)(nil), "evictionplugin.v1alpha1.EvictPod")
	proto.RegisterType((*GetEvictPodsRequest)(nil), "evictionplugin.v1alpha1.GetEvictPodsRequest")
	proto.RegisterType((*GetEvictPodsResponse)(nil), "evictionplugin.v1alpha1.GetEvictPodsResponse")
	proto.RegisterType((*DeletionOptions)(nil), "evictionplugin.v1alpha1.DeletionOptions")
}

func init() { proto.RegisterFile("v1alpha1/api.proto", fileDescriptor_78941759e4c5eff9) }

var fileDescriptor_78941759e4c5eff9 = []byte{
	// 883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xcf, 0x24, 0xdd, 0xa6, 0x79, 0xf9, 0xd3, 0x74, 0xa8, 0xd8, 0x90, 0x43, 0x08, 0x46, 0x80,
	0xb7, 0x62, 0x1d, 0x9a, 0x45, 0xa8, 0x12, 0x97, 0x2d, 0x4d, 0xe8, 0xae, 0x44, 0x93, 0x68, 0x12,
	0x21, 0xc1, 0xc5, 0x72, 0xed, 0xd7, 0xd4, 0x22, 0xce, 0x18, 0x7b, 0x12, 0xa9, 0x27, 0xf8, 0x08,
	0x7b, 0xe6, 0xc8, 0x95, 0x2f, 0xc1, 0x71, 0x8f, 0x1c, 0x39, 0xd2, 0xf2, 0x19, 0xb8, 0xa3, 0x99,
	0x89, 0xd3, 0xa4, 0x1b, 0x77, 0x17, 0xf6, 0x94, 0x79, 0xbf, 0x79, 0xef, 0x37, 0xbf, 0x79, 0x7f,
	0xc6, 0x01, 0x3a, 0x3f, 0x74, 0x26, 0xe1, 0xa5, 0x73, 0xd8, 0x72, 0x42, 0xdf, 0x0a, 0x23, 0x2e,
	0x38, 0x7d, 0x88, 0x73, 0xdf, 0x15, 0x3e, 0x9f, 0x86, 0x93, 0xd9, 0xd8, 0x9f, 0x5a, 0x89, 0x4b,
	0xfd, 0xf1, 0xd8, 0x17, 0x97, 0xb3, 0x73, 0xcb, 0xe5, 0x41, 0x6b, 0xcc, 0xc7, 0xbc, 0xa5, 0xfc,
	0xcf, 0x67, 0x17, 0xca, 0x52, 0x86, 0x5a, 0x69, 0x9e, 0xba, 0xf1, 0xc3, 0x51, 0x6c, 0xf9, 0x5c,
	0x32, 0xb7, 0x5c, 0x1e, 0x61, 0x6b, 0x7e, 0xd8, 0x1a, 0xe3, 0x14, 0x23, 0x47, 0xa0, 0xa7, 0x7d,
	0x8c, 0x3c, 0x3c, 0xe8, 0x06, 0xa1, 0xb8, 0x32, 0x7e, 0x27, 0x50, 0x38, 0xe1, 0x53, 0xcf, 0x97,
	0x07, 0xd3, 0x33, 0xa8, 0xb8, 0x89, 0x61, 0x8b, 0xab, 0x10, 0x6b, 0xa4, 0x49, 0xcc, 0x4a, 0xfb,
	0x63, 0x2b, 0x45, 0x9b, 0xb5, 0x8c, 0x1d, 0x5d, 0x85, 0xc8, 0xca, 0xee, 0xaa, 0x49, 0x6b, 0x90,
	0xc7, 0x8b, 0x0b, 0x74, 0x45, 0x5c, 0xcb, 0x36, 0x73, 0x66, 0x81, 0x25, 0x26, 0xfd, 0x68, 0xf5,
	0xa0, 0xa9, 0x13, 0x60, 0x2d, 0xd7, 0x24, 0x66, 0x61, 0x85, 0xa0, 0xe7, 0x04, 0x48, 0x3f, 0x84,
	0x72, 0x80, 0xc2, 0x5e, 0x82, 0xb5, 0xad, 0x26, 0x31, 0x77, 0x58, 0x29, 0x40, 0xb1, 0x3c, 0xd8,
	0xf8, 0x35, 0x07, 0xfb, 0xa3, 0xcb, 0x08, 0xe3, 0x4b, 0x3e, 0xf1, 0xce, 0x50, 0x30, 0x8c, 0x43,
	0x3e, 0x8d, 0x91, 0x7e, 0x02, 0xbb, 0x22, 0xc1, 0xed, 0xb9, 0x33, 0x99, 0xe9, 0xeb, 0x10, 0x56,
	0x59, 0xc2, 0xdf, 0x4a, 0x54, 0xaa, 0xe1, 0xe7, 0x31, 0x46, 0x73, 0x4c, 0xfc, 0xb2, 0xca, 0xaf,
	0x9c, 0xa0, 0xda, 0xed, 0x3b, 0xa0, 0xb7, 0x7c, 0x3c, 0x94, 0x09, 0xe5, 0x91, 0x12, 0x5e, 0x69,
	0x1f, 0xa4, 0x66, 0x68, 0x29, 0xad, 0xbf, 0x88, 0x60, 0x7b, 0xe2, 0x2e, 0x44, 0x3b, 0xb0, 0x23,
	0x2f, 0xaa, 0x52, 0xbe, 0xa5, 0x08, 0x1f, 0xbd, 0x9e, 0xf0, 0x0c, 0x85, 0xca, 0x7a, 0x3e, 0xd0,
	0x0b, 0x79, 0x8f, 0x24, 0xc8, 0x8e, 0x5d, 0x1e, 0x62, 0xed, 0x81, 0xce, 0x6a, 0x82, 0x0e, 0x25,
	0x48, 0x3f, 0x83, 0xfd, 0x71, 0xe4, 0xb8, 0x68, 0x87, 0x18, 0xf9, 0xdc, 0xb3, 0x63, 0x94, 0x09,
	0x8e, 0x6b, 0xdb, 0x4d, 0x62, 0xe6, 0x18, 0x55, 0x7b, 0x03, 0xb5, 0x35, 0xd4, 0x3b, 0xf4, 0x29,
	0x14, 0x6e, 0x6b, 0x90, 0x6f, 0x12, 0xb3, 0xd8, 0x36, 0x5e, 0xdf, 0x12, 0xec, 0x36, 0xc8, 0x78,
	0x41, 0xe0, 0xbd, 0x53, 0x14, 0x23, 0x1e, 0x76, 0x17, 0x61, 0x03, 0xee, 0xc5, 0x0c, 0x7f, 0x9c,
	0x61, 0x2c, 0xe8, 0x11, 0x14, 0x1d, 0x57, 0xf8, 0x73, 0xb4, 0x43, 0xee, 0xc5, 0x35, 0xd2, 0xcc,
	0x99, 0xc5, 0xf6, 0x43, 0x4b, 0x37, 0xb2, 0x25, 0x47, 0x44, 0x36, 0xb2, 0x35, 0x3f, 0xb4, 0x06,
	0xdc, 0x63, 0xa0, 0x7d, 0x25, 0x01, 0xa5, 0xb0, 0x25, 0x78, 0xd8, 0x53, 0x05, 0xdb, 0x62, 0x6a,
	0xbd, 0x21, 0x0d, 0xb9, 0x0d, 0x69, 0x30, 0x7e, 0x23, 0x50, 0xdf, 0x24, 0x69, 0xd1, 0x3d, 0x47,
	0x50, 0x14, 0x4e, 0x34, 0x46, 0xf1, 0x66, 0x9a, 0xb4, 0xaf, 0xd2, 0x34, 0x84, 0xaa, 0x87, 0x13,
	0x54, 0xe7, 0xf3, 0x50, 0xfe, 0xc4, 0x4a, 0x5f, 0xb1, 0x6d, 0xa6, 0x26, 0xad, 0xb3, 0x08, 0xe8,
	0x6b, 0x7f, 0xb6, 0xeb, 0xad, 0x03, 0xc6, 0x3f, 0x04, 0x76, 0x94, 0xce, 0x01, 0xf7, 0xe8, 0x23,
	0xc8, 0x85, 0xdc, 0x53, 0xdd, 0x7c, 0x8f, 0x26, 0xe9, 0x43, 0xdf, 0x85, 0xed, 0x08, 0x9d, 0x98,
	0x4f, 0x95, 0x84, 0x02, 0x5b, 0x58, 0x1b, 0x45, 0xe6, 0xde, 0x52, 0x24, 0x7d, 0x1f, 0x8a, 0x17,
	0x3c, 0x72, 0xd1, 0x56, 0x0c, 0x8b, 0x69, 0x05, 0x05, 0x29, 0xed, 0xb2, 0xf5, 0x96, 0xa5, 0xd1,
	0xec, 0x7a, 0xfa, 0x75, 0x9f, 0xd2, 0x64, 0x6f, 0xa0, 0xb6, 0xe4, 0x13, 0x60, 0xf4, 0xe1, 0x9d,
	0x53, 0x14, 0xc9, 0xcd, 0xdf, 0xbe, 0x63, 0x8c, 0x5f, 0x08, 0xec, 0xaf, 0x33, 0x2e, 0x0a, 0xfe,
	0x14, 0x40, 0x9d, 0xbf, 0xca, 0xf8, 0x41, 0x6a, 0x2e, 0x92, 0x78, 0x56, 0xc0, 0x84, 0x69, 0x7d,
	0x4c, 0xb2, 0xff, 0x67, 0x4c, 0x4e, 0x60, 0xf7, 0x4e, 0x92, 0x53, 0xa7, 0x95, 0xa4, 0x4d, 0xeb,
	0xc1, 0x97, 0x50, 0xbd, 0xfb, 0x46, 0xd0, 0x22, 0xe4, 0x7b, 0xfd, 0x91, 0x7d, 0xd6, 0x1d, 0x55,
	0x33, 0xb4, 0x04, 0x3b, 0xc3, 0xfe, 0xd7, 0xda, 0x22, 0xd2, 0x7a, 0x76, 0xcc, 0x3a, 0xca, 0xca,
	0x1e, 0x7c, 0x0e, 0x7b, 0xaf, 0xbc, 0x58, 0xb4, 0x0c, 0x85, 0x6f, 0xba, 0xc3, 0xa1, 0x3d, 0x7a,
	0x76, 0xdc, 0xab, 0x66, 0x68, 0x15, 0x4a, 0xa7, 0xac, 0x7b, 0x3c, 0xea, 0x32, 0x8d, 0x90, 0x83,
	0x2f, 0xa0, 0xbc, 0xf6, 0x25, 0xa0, 0x14, 0x2a, 0xbd, 0x7e, 0xa7, 0x6b, 0x9f, 0xf4, 0x7b, 0x9d,
	0xe7, 0xa3, 0xe7, 0x7d, 0x19, 0xb6, 0x07, 0xe5, 0x93, 0x1e, 0x5b, 0x81, 0x48, 0xfb, 0x3a, 0x0b,
	0x95, 0xee, 0x5a, 0xd1, 0xa9, 0x0d, 0xa5, 0x55, 0xf5, 0xb4, 0x91, 0x5e, 0x02, 0xf9, 0x05, 0xab,
	0x3f, 0x7e, 0xa3, 0x87, 0x32, 0xa9, 0xb2, 0x91, 0xa1, 0x3f, 0x01, 0x7d, 0x75, 0xec, 0x69, 0x3b,
	0x95, 0x26, 0xf5, 0xd9, 0xaa, 0x3f, 0xf9, 0x4f, 0x31, 0x4b, 0x01, 0x01, 0x94, 0x56, 0x1b, 0x90,
	0x7e, 0x7a, 0x1f, 0xcd, 0xdd, 0xce, 0xbf, 0xe7, 0xbe, 0x9b, 0xba, 0xda, 0xc8, 0x7c, 0x65, 0xbe,
	0xbc, 0x6e, 0x90, 0x3f, 0xaf, 0x1b, 0x99, 0x9f, 0x6f, 0x1a, 0xe4, 0xe5, 0x4d, 0x83, 0xfc, 0x71,
	0xd3, 0x20, 0x7f, 0xdd, 0x34, 0xc8, 0x8b, 0xbf, 0x1b, 0x99, 0xef, 0xc1, 0x6a, 0x25, 0x04, 0xe7,
	0xdb, 0xea, 0xcf, 0xc1, 0x93, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xe9, 0x6b, 0x20, 0x42, 0x9e,
	0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EvictionPluginClient is the client API for EvictionPlugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EvictionPluginClient interface {
	ThresholdMet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ThresholdMetResponse, error)
	GetTopEvictionPods(ctx context.Context, in *GetTopEvictionPodsRequest, opts ...grpc.CallOption) (*GetTopEvictionPodsResponse, error)
	GetEvictPods(ctx context.Context, in *GetEvictPodsRequest, opts ...grpc.CallOption) (*GetEvictPodsResponse, error)
}

type evictionPluginClient struct {
	cc *grpc.ClientConn
}

func NewEvictionPluginClient(cc *grpc.ClientConn) EvictionPluginClient {
	return &evictionPluginClient{cc}
}

func (c *evictionPluginClient) ThresholdMet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ThresholdMetResponse, error) {
	out := new(ThresholdMetResponse)
	err := c.cc.Invoke(ctx, "/evictionplugin.v1alpha1.EvictionPlugin/ThresholdMet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evictionPluginClient) GetTopEvictionPods(ctx context.Context, in *GetTopEvictionPodsRequest, opts ...grpc.CallOption) (*GetTopEvictionPodsResponse, error) {
	out := new(GetTopEvictionPodsResponse)
	err := c.cc.Invoke(ctx, "/evictionplugin.v1alpha1.EvictionPlugin/GetTopEvictionPods", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evictionPluginClient) GetEvictPods(ctx context.Context, in *GetEvictPodsRequest, opts ...grpc.CallOption) (*GetEvictPodsResponse, error) {
	out := new(GetEvictPodsResponse)
	err := c.cc.Invoke(ctx, "/evictionplugin.v1alpha1.EvictionPlugin/GetEvictPods", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EvictionPluginServer is the server API for EvictionPlugin service.
type EvictionPluginServer interface {
	ThresholdMet(context.Context, *Empty) (*ThresholdMetResponse, error)
	GetTopEvictionPods(context.Context, *GetTopEvictionPodsRequest) (*GetTopEvictionPodsResponse, error)
	GetEvictPods(context.Context, *GetEvictPodsRequest) (*GetEvictPodsResponse, error)
}

// UnimplementedEvictionPluginServer can be embedded to have forward compatible implementations.
type UnimplementedEvictionPluginServer struct {
}

func (*UnimplementedEvictionPluginServer) ThresholdMet(ctx context.Context, req *Empty) (*ThresholdMetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThresholdMet not implemented")
}
func (*UnimplementedEvictionPluginServer) GetTopEvictionPods(ctx context.Context, req *GetTopEvictionPodsRequest) (*GetTopEvictionPodsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopEvictionPods not implemented")
}
func (*UnimplementedEvictionPluginServer) GetEvictPods(ctx context.Context, req *GetEvictPodsRequest) (*GetEvictPodsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvictPods not implemented")
}

func RegisterEvictionPluginServer(s *grpc.Server, srv EvictionPluginServer) {
	s.RegisterService(&_EvictionPlugin_serviceDesc, srv)
}

func _EvictionPlugin_ThresholdMet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvictionPluginServer).ThresholdMet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evictionplugin.v1alpha1.EvictionPlugin/ThresholdMet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvictionPluginServer).ThresholdMet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvictionPlugin_GetTopEvictionPods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopEvictionPodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvictionPluginServer).GetTopEvictionPods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evictionplugin.v1alpha1.EvictionPlugin/GetTopEvictionPods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvictionPluginServer).GetTopEvictionPods(ctx, req.(*GetTopEvictionPodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvictionPlugin_GetEvictPods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEvictPodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvictionPluginServer).GetEvictPods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evictionplugin.v1alpha1.EvictionPlugin/GetEvictPods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvictionPluginServer).GetEvictPods(ctx, req.(*GetEvictPodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EvictionPlugin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "evictionplugin.v1alpha1.EvictionPlugin",
	HandlerType: (*EvictionPluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ThresholdMet",
			Handler:    _EvictionPlugin_ThresholdMet_Handler,
		},
		{
			MethodName: "GetTopEvictionPods",
			Handler:    _EvictionPlugin_GetTopEvictionPods_Handler,
		},
		{
			MethodName: "GetEvictPods",
			Handler:    _EvictionPlugin_GetEvictPods_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1alpha1/api.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetCondition {
		i--
		if m.MetCondition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ConditionName) > 0 {
		i -= len(m.ConditionName)
		copy(dAtA[i:], m.ConditionName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ConditionName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Effects) > 0 {
		for iNdEx := len(m.Effects) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Effects[iNdEx])
			copy(dAtA[i:], m.Effects[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Effects[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ConditionType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ConditionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdMetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdMetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdMetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Condition != nil {
		{
			size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.GracePeriodSeconds != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GracePeriodSeconds))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EvictionScope) > 0 {
		i -= len(m.EvictionScope)
		copy(dAtA[i:], m.EvictionScope)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EvictionScope)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MetType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MetType))
		i--
		dAtA[i] = 0x20
	}
	if m.ThresholdOperator != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ThresholdOperator))
		i--
		dAtA[i] = 0x18
	}
	if m.ObservedValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ObservedValue))))
		i--
		dAtA[i] = 0x11
	}
	if m.ThresholdValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ThresholdValue))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *GetTopEvictionPodsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopEvictionPodsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTopEvictionPodsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvictionScope) > 0 {
		i -= len(m.EvictionScope)
		copy(dAtA[i:], m.EvictionScope)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EvictionScope)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TopN != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TopN))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ActivePods) > 0 {
		for iNdEx := len(m.ActivePods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActivePods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetTopEvictionPodsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopEvictionPodsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTopEvictionPodsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletionOptions != nil {
		{
			size, err := m.DeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TargetPods) > 0 {
		for iNdEx := len(m.TargetPods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TargetPods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvictPod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvictPod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvictPod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvictionPluginName) > 0 {
		i -= len(m.EvictionPluginName)
		copy(dAtA[i:], m.EvictionPluginName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EvictionPluginName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ForceEvict {
		i--
		if m.ForceEvict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DeletionOptions != nil {
		{
			size, err := m.DeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pod != nil {
		{
			size, err := m.Pod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetEvictPodsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEvictPodsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetEvictPodsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActivePods) > 0 {
		for iNdEx := len(m.ActivePods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActivePods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetEvictPodsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEvictPodsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetEvictPodsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Condition != nil {
		{
			size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.EvictPods) > 0 {
		for iNdEx := len(m.EvictPods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EvictPods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeletionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GracePeriodSeconds != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GracePeriodSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionType != 0 {
		n += 1 + sovApi(uint64(m.ConditionType))
	}
	if len(m.Effects) > 0 {
		for _, s := range m.Effects {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.ConditionName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MetCondition {
		n += 2
	}
	return n
}

func (m *ThresholdMetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ThresholdValue != 0 {
		n += 9
	}
	if m.ObservedValue != 0 {
		n += 9
	}
	if m.ThresholdOperator != 0 {
		n += 1 + sovApi(uint64(m.ThresholdOperator))
	}
	if m.MetType != 0 {
		n += 1 + sovApi(uint64(m.MetType))
	}
	l = len(m.EvictionScope)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GracePeriodSeconds != 0 {
		n += 1 + sovApi(uint64(m.GracePeriodSeconds))
	}
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetTopEvictionPodsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ActivePods) > 0 {
		for _, e := range m.ActivePods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.TopN != 0 {
		n += 1 + sovApi(uint64(m.TopN))
	}
	l = len(m.EvictionScope)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetTopEvictionPodsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TargetPods) > 0 {
		for _, e := range m.TargetPods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.DeletionOptions != nil {
		l = m.DeletionOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *EvictPod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pod != nil {
		l = m.Pod.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DeletionOptions != nil {
		l = m.DeletionOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ForceEvict {
		n += 2
	}
	l = len(m.EvictionPluginName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetEvictPodsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ActivePods) > 0 {
		for _, e := range m.ActivePods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetEvictPodsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EvictPods) > 0 {
		for _, e := range m.EvictPods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeletionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GracePeriodSeconds != 0 {
		n += 1 + sovApi(uint64(m.GracePeriodSeconds))
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *Condition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition{`,
		`ConditionType:` + fmt.Sprintf("%v", this.ConditionType) + `,`,
		`Effects:` + fmt.Sprintf("%v", this.Effects) + `,`,
		`ConditionName:` + fmt.Sprintf("%v", this.ConditionName) + `,`,
		`MetCondition:` + fmt.Sprintf("%v", this.MetCondition) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ThresholdMetResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ThresholdMetResponse{`,
		`ThresholdValue:` + fmt.Sprintf("%v", this.ThresholdValue) + `,`,
		`ObservedValue:` + fmt.Sprintf("%v", this.ObservedValue) + `,`,
		`ThresholdOperator:` + fmt.Sprintf("%v", this.ThresholdOperator) + `,`,
		`MetType:` + fmt.Sprintf("%v", this.MetType) + `,`,
		`EvictionScope:` + fmt.Sprintf("%v", this.EvictionScope) + `,`,
		`GracePeriodSeconds:` + fmt.Sprintf("%v", this.GracePeriodSeconds) + `,`,
		`Condition:` + strings.Replace(this.Condition.String(), "Condition", "Condition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTopEvictionPodsRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForActivePods := "[]*Pod{"
	for _, f := range this.ActivePods {
		repeatedStringForActivePods += strings.Replace(fmt.Sprintf("%v", f), "Pod", "v1.Pod", 1) + ","
	}
	repeatedStringForActivePods += "}"
	s := strings.Join([]string{`&GetTopEvictionPodsRequest{`,
		`ActivePods:` + repeatedStringForActivePods + `,`,
		`TopN:` + fmt.Sprintf("%v", this.TopN) + `,`,
		`EvictionScope:` + fmt.Sprintf("%v", this.EvictionScope) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTopEvictionPodsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTargetPods := "[]*Pod{"
	for _, f := range this.TargetPods {
		repeatedStringForTargetPods += strings.Replace(fmt.Sprintf("%v", f), "Pod", "v1.Pod", 1) + ","
	}
	repeatedStringForTargetPods += "}"
	s := strings.Join([]string{`&GetTopEvictionPodsResponse{`,
		`TargetPods:` + repeatedStringForTargetPods + `,`,
		`DeletionOptions:` + strings.Replace(this.DeletionOptions.String(), "DeletionOptions", "DeletionOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EvictPod) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EvictPod{`,
		`Pod:` + strings.Replace(fmt.Sprintf("%v", this.Pod), "Pod", "v1.Pod", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`DeletionOptions:` + strings.Replace(this.DeletionOptions.String(), "DeletionOptions", "DeletionOptions", 1) + `,`,
		`ForceEvict:` + fmt.Sprintf("%v", this.ForceEvict) + `,`,
		`EvictionPluginName:` + fmt.Sprintf("%v", this.EvictionPluginName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetEvictPodsRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForActivePods := "[]*Pod{"
	for _, f := range this.ActivePods {
		repeatedStringForActivePods += strings.Replace(fmt.Sprintf("%v", f), "Pod", "v1.Pod", 1) + ","
	}
	repeatedStringForActivePods += "}"
	s := strings.Join([]string{`&GetEvictPodsRequest{`,
		`ActivePods:` + repeatedStringForActivePods + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetEvictPodsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEvictPods := "[]*EvictPod{"
	for _, f := range this.EvictPods {
		repeatedStringForEvictPods += strings.Replace(f.String(), "EvictPod", "EvictPod", 1) + ","
	}
	repeatedStringForEvictPods += "}"
	s := strings.Join([]string{`&GetEvictPodsResponse{`,
		`EvictPods:` + repeatedStringForEvictPods + `,`,
		`Condition:` + strings.Replace(this.Condition.String(), "Condition", "Condition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeletionOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeletionOptions{`,
		`GracePeriodSeconds:` + fmt.Sprintf("%v", this.GracePeriodSeconds) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			m.ConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionType |= ConditionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effects", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effects = append(m.Effects, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetCondition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MetCondition = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdMetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdMetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdMetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ThresholdValue = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ObservedValue = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdOperator", wireType)
			}
			m.ThresholdOperator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThresholdOperator |= ThresholdOperator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetType", wireType)
			}
			m.MetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetType |= ThresholdMetType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvictionScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvictionScope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriodSeconds", wireType)
			}
			m.GracePeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriodSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Condition{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopEvictionPodsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopEvictionPodsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopEvictionPodsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivePods = append(m.ActivePods, &v1.Pod{})
			if err := m.ActivePods[len(m.ActivePods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopN", wireType)
			}
			m.TopN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopN |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvictionScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvictionScope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopEvictionPodsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopEvictionPodsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopEvictionPodsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetPods = append(m.TargetPods, &v1.Pod{})
			if err := m.TargetPods[len(m.TargetPods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionOptions == nil {
				m.DeletionOptions = &DeletionOptions{}
			}
			if err := m.DeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvictPod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvictPod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvictPod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pod == nil {
				m.Pod = &v1.Pod{}
			}
			if err := m.Pod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionOptions == nil {
				m.DeletionOptions = &DeletionOptions{}
			}
			if err := m.DeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceEvict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceEvict = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvictionPluginName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvictionPluginName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEvictPodsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEvictPodsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEvictPodsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivePods = append(m.ActivePods, &v1.Pod{})
			if err := m.ActivePods[len(m.ActivePods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEvictPodsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEvictPodsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEvictPodsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvictPods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvictPods = append(m.EvictPods, &EvictPod{})
			if err := m.EvictPods[len(m.EvictPods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Condition{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriodSeconds", wireType)
			}
			m.GracePeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriodSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
